import{_ as o,c as a,o as t,aG as s}from"./chunks/framework.Bwfhi3i_.js";const p=JSON.parse('{"title":"第六章事务并发和锁","description":"","frontmatter":{"title":"第六章事务并发和锁","author":"Zack Zheng","date":"2025/07/07 09:30","categories":["PostgreSQL"],"tags":["SQL","唐成","PostgreSQL"]},"headers":[],"relativePath":"books/techAndCodes/PostgreSQL修炼之道_第2版/第六章事务并发和锁.md","filePath":"books/techAndCodes/PostgreSQL修炼之道_第2版/第六章事务并发和锁.md","lastUpdated":1755154786000}'),r={name:"books/techAndCodes/PostgreSQL修炼之道_第2版/第六章事务并发和锁.md"};function c(d,e,i,l,n,_){return t(),a("div",null,[...e[0]||(e[0]=[s('<h4 id="事务" tabindex="-1">事务 <a class="header-anchor" href="#事务" aria-label="Permalink to &quot;事务&quot;">​</a></h4><p>对于一组相关操作，通常需要全部成功或者全部失败。这组相关操作称为事务</p><p><b>特性（ACID）</b></p><ul><li>原子性(Atomicity): 事务必须以一个整体单元的形式进行工作，对于其数据的修改，要么全部执行，要么全都不执行。如果只执行事务中多个操作的前半部分就出现错误，那么必须回滚所有操作，让数据在逻辑上回滚到原先的状态。</li><li>一致性(Consistency): 在事务完成时，必须使所有的数据都保持在一致状态</li><li>隔离性(Isolation): 事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务是不会查看中间状态的数据的。</li><li>持久性(Durability): 事务完成之后，它对于系统的影响是永久性的。即使今后出现致命的系统故障（如机器重启、断电），数据也将一直保持。</li></ul><h4 id="savepoint-保存点" tabindex="-1">savepoint(保存点) <a class="header-anchor" href="#savepoint-保存点" aria-label="Permalink to &quot;savepoint(保存点)&quot;">​</a></h4><p>在一个大的事务中，可以把操作过程分成几个部分，每一个部分执行成功可以建一个保存点，若后面的部分执行失败，则回滚到此保存点，不必回滚整个事务。</p><h4 id="锁机制" tabindex="-1">锁机制 <a class="header-anchor" href="#锁机制" aria-label="Permalink to &quot;锁机制&quot;">​</a></h4><p>PostgreSQL有2类锁：表级锁和行级锁</p><p>表级锁有<code>share</code>和<code>exclusive</code>两种<br><code>share</code>锁相当于读锁，表中内容不能变化，可为多个事务加上此锁，只要任意一个用户不释放此读锁，其他用户就不能修改这个表<br><code>exclusive</code>相当于写锁，这时别的进程既不能写也不能读这条数据<br> 多版本功能新增的2个锁<br><code>access share</code>: 表明加上这个锁，即使是正在修改数据的情况下也允许读数据<br><code>access exclusion</code>: 意思是即使有多个版本的功能，也不允许访问数据<br> 行级锁（<code>row share</code>、<code>row exclusive</code>）和表级锁会产生冲突<br><code>share update exclusive</code>、<code>share row exclusive</code></p>',9)])])}const u=o(r,[["render",c]]);export{p as __pageData,u as default};
