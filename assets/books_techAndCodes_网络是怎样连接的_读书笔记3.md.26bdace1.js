import{_ as e,c as r,o as a,a as i}from"./app.cf1ad779.js";const C=JSON.parse('{"title":"网络是怎样连接的3","description":"","frontmatter":{"title":"网络是怎样连接的3","author":"Zack Zheng","date":"2023/10/20 21:42","categories":["网络是怎样连接的"],"tags":["http","读书笔记"]},"headers":[],"relativePath":"books/techAndCodes/网络是怎样连接的/读书笔记3.md","lastUpdated":1697726662000}'),t={name:"books/techAndCodes/网络是怎样连接的/读书笔记3.md"},l=i('<p>先来分个层</p><p>{<br> 应用程序（浏览器、邮件客户端等）<br> 包含【Socket库】<br> }<br> {<br> 协议栈<br> TCP/UDP<br> 一般应用程序都是使用TCP收发数据、诸如DNS查询收发短数据是使用UDP<br> IP协议传送网络包（互联网传输的数据会被切成几十-几千字节的块，每一块数据就成为一个网络包）<br> }<br> {<br> 网卡驱动程序<br> }<br> {<br> 硬件网卡<br> }</p><hr><p>每一个网络包都有TCP头部信息（控制信息），包含：</p><ol><li>双方端口</li><li>序号（发送方告知这个数据包相当于所有数据的第几个字节）</li><li>ACK号（接收方告知发送方，已经收到了第几个字节。acknowledge的缩写）</li><li>数据偏移量（数据搁哪开始的）</li><li>控制位（SYN相互确认序号，表示连接、FIN表示断开。。。。）</li><li>其他。。。。</li></ol><h4 id="连接的具体过程" tabindex="-1">连接的具体过程 <a class="header-anchor" href="#连接的具体过程" aria-hidden="true">#</a></h4><ol><li>从Socket库的connect(描述符、服务器ip和端口)开始</li><li>创建TCP头部信息，将控制位SYN设为1，表示连接；ACK为0</li><li>协议栈中的TCP模块委托IP模块发送，与服务器TCP模块交换控制信息</li><li>服务器TCP模块根据信息找到端口对应的套接字</li><li>找到后在套接字中写入信息，将状态改为正在连接，ACK设为1</li><li>同客户端将TCP头部信息委托IP模块发送到客户端</li><li>客户端收到，向套接字中写入信息，将状态修改为连接完毕，将ACK修改为1，发回服务器（表示刚才收到）</li><li>服务器再次收到，连接全部完成</li></ol><h4 id="序号和ack的用法-传送数据过程中" tabindex="-1">序号和ACK的用法（传送数据过程中） <a class="header-anchor" href="#序号和ack的用法-传送数据过程中" aria-hidden="true">#</a></h4><p>序号一般不是从1开始的（防止预测通信过程而发动攻击）<br> （在上面的第7步中，客户端告诉了服务端，随机生成的序号是几）</p><p>为了简化理解，以下描述把序号作为1开始：</p><p>发送方：我现在发送所有数据的第1（序号1）字节，一共1460字节<br> 接收方：已收到1460字节，确认ACK：1461（字节数（算出来的=网络包-头部信息）+序号）<br> 发送方：我现在发送数据从第1461字节（序号1461），一共1460字节<br> 接收方：已收到1460字节，确认ACK：2921（上次收到1460字节，下次序号不是1461，则丢包了）</p><p>注意：数据是双向传输的，所以以上过程也是双向的，为了方便理解，上面只简述了从客户端传输数据至服务器端</p><p>传输的包存放在缓冲区，通过ACK这个机制，可以判断哪些包丢了，丢了重发<br> 如果TCP重传几次都无效，则强制结束通信，并向应用程序报错</p><h5 id="以上是基本原理-实际情况非常有意思" tabindex="-1">以上是基本原理，实际情况非常有意思 <a class="header-anchor" href="#以上是基本原理-实际情况非常有意思" aria-hidden="true">#</a></h5><p>1.假设网络繁忙拥堵，长时间收不到ACK就会重传，频繁重传则会导致网络更堵<br> 那我多等一会儿<br> 多等就会延迟，延迟也会导致网络变慢<br> （动态调整）</p><p>2.每发一个包，等ACK再发下一个，太浪费时间<br> 所以，发包不等ACK，连续发下一个，这有一个问题<br> 接收方要处理数据（还原数据，算ACK），假如，发的速度超过处理的速度<br> 则会挤爆接收方的缓冲区，导致后面的数据都进不来 （滑动窗口）</p>',16),o=[l];function c(d,p,s,n,b,_){return a(),r("div",null,o)}const A=e(t,[["render",c]]);export{C as __pageData,A as default};
