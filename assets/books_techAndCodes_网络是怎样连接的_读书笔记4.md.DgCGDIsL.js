import{_ as e,c as a,o,aG as p}from"./chunks/framework.DGtm8y85.js";const h=JSON.parse('{"title":"网络是怎样连接的4","description":"","frontmatter":{"title":"网络是怎样连接的4","author":"Zack Zheng","date":"2023/10/20 21:42","categories":["网络是怎样连接的"],"tags":["http","读书笔记","计算机"]},"headers":[],"relativePath":"books/techAndCodes/网络是怎样连接的/读书笔记4.md","filePath":"books/techAndCodes/网络是怎样连接的/读书笔记4.md","lastUpdated":1755249536000}'),i={name:"books/techAndCodes/网络是怎样连接的/读书笔记4.md"};function r(s,t,l,c,d,n){return o(),a("div",null,t[0]||(t[0]=[p('<p>关闭连接:客户端和服务器都可以发起关闭连接</p><p>假设服务器发起的，则过程如下：</p><ol><li>TCP头部控制位FIN为1（调用Socket库的close程序，委托IP模块发送）</li><li>客户端收到，返回ACK号（客户端套接字标记为断开）</li><li>客户端生成FIN为1的TCP包，发送至服务器</li><li>服务器返回ACK，通信结束</li></ol><p>（断开的操作，也会丢包重发，所以套接字不会立即删除，防止一些误操作）</p><h5 id="tcp-ip包的结构" tabindex="-1">TCP/IP包的结构 <a class="header-anchor" href="#tcp-ip包的结构" aria-label="Permalink to &quot;TCP/IP包的结构&quot;">​</a></h5><p>MAC头部+IP头部+TCP头部+数据块</p><p>传输方向：客户端-&gt;集线器-&gt;路由器-&gt;....路由器-&gt;服务器</p><p>集线器：集线器里面有一张表，根据MAC头部（以太网）知道包往哪个方向（路由器）传 路由器：路由器里面也有一张表，根据IP头部，改写MAC头部，知道往哪一个路由器传</p><p>分层有助于架构灵活，这里的MAC头部（以太网可以替换为无线局域网、ADSL、FTTH等）</p><h5 id="防火墙的结构和原理" tabindex="-1">防火墙的结构和原理 <a class="header-anchor" href="#防火墙的结构和原理" aria-label="Permalink to &quot;防火墙的结构和原理&quot;">​</a></h5><p>防火墙只允许发往特定服务器的特定应用程序的包通过（包过滤）</p>',11)]))}const C=e(i,[["render",r]]);export{h as __pageData,C as default};
