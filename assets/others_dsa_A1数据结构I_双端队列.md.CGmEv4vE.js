import{_ as a,c as r,o as t,aG as i}from"./chunks/framework.CdnsPyyz.js";const m=JSON.parse('{"title":"双端队列","description":"","frontmatter":{"title":"双端队列","author":"Zack Zheng","date":"2025/03/06 10:57","categories":["数据结构和算法"],"tags":["数据结构","算法"]},"headers":[],"relativePath":"others/dsa/A1数据结构I/双端队列.md","filePath":"others/dsa/A1数据结构I/双端队列.md","lastUpdated":1742521010000}'),o={name:"others/dsa/A1数据结构I/双端队列.md"};function l(c,e,d,n,s,h){return t(),r("div",null,e[0]||(e[0]=[i('<p>双端队列（Deque 或 Double Ended Queue）是一种队列，在这种队列中，元素的插入和删除操作既可以在队头进行，也可以在队尾进行。因此，它并不遵循先进先出（FIFO，即 First In First Out）规则。</p><p><img src="https://gitee.com/zackzhengxy/picGallery/raw/main/imgs/deque.webp" alt="双端队列"></p><h4 id="双端队列的类型" tabindex="-1">双端队列的类型 <a class="header-anchor" href="#双端队列的类型" aria-label="Permalink to &quot;双端队列的类型&quot;">​</a></h4><h5 id="输入受限的双端队列" tabindex="-1">输入受限的双端队列 <a class="header-anchor" href="#输入受限的双端队列" aria-label="Permalink to &quot;输入受限的双端队列&quot;">​</a></h5><p>在这种双端队列中，输入操作被限制在一端进行，但允许在两端进行删除操作。</p><h5 id="输出受限的双端队列" tabindex="-1">输出受限的双端队列 <a class="header-anchor" href="#输出受限的双端队列" aria-label="Permalink to &quot;输出受限的双端队列&quot;">​</a></h5><p>在这种双端队列中，输出操作被限制在一端进行，但允许在两端进行插入操作。</p><h4 id="双端队列的操作" tabindex="-1">双端队列的操作 <a class="header-anchor" href="#双端队列的操作" aria-label="Permalink to &quot;双端队列的操作&quot;">​</a></h4><p>下面是双端队列的<a href="./循环队列.html">循环数组</a>实现方式。在循环数组中，如果数组已满，我们就从数组的开头重新开始操作。</p><p>但在使用线性数组实现（双端队列）时，如果数组已满，就无法再插入更多元素了。在下面的每一项操作中，如果数组已满，就会抛出 “溢出消息”。</p><p>在执行以下操作之前，需要遵循这些步骤。</p><ol><li>取一个大小为 n 的数组（双端队列）。</li><li>设置两个指针，令头指针<code>front</code>等于 -1，尾指针<code>rear</code>等于 0。</li></ol><p><img src="https://gitee.com/zackzhengxy/picGallery/raw/main/imgs/deque-array.webp" alt="为双端队列初始化数组和指针"></p><h5 id="_1-在头部插入" tabindex="-1">1.在头部插入 <a class="header-anchor" href="#_1-在头部插入" aria-label="Permalink to &quot;1.在头部插入&quot;">​</a></h5><p>此操作在（双端队列的）前端添加一个元素。</p><ol><li>检查队列是不是满了 <img src="https://gitee.com/zackzhengxy/picGallery/raw/main/imgs/deque-insert-front-1.webp" alt="检查front的位置"></li><li>如果双端队列已满（即<code>(front == 0 &amp;&amp; rear == n - 1) || (front == rear + 1)</code>，则无法执行插入操作（出现溢出情况）。</li><li>如果双端队列是空的，重新初始化<code>front = 0</code>。并且将新值添加到<code>array[front]</code></li><li>如果<code>front = 0</code>，重新初始化<code>front = n - 1</code>（最后一个索引位置） <img src="https://gitee.com/zackzhengxy/picGallery/raw/main/imgs/deque-insert-front-2.webp" alt="从front移动到end"></li><li>否则，<code>front</code>加1</li><li>将新值<code>5</code>添加到<code>array[front]</code><img src="https://gitee.com/zackzhengxy/picGallery/raw/main/imgs/deque-insert-front-3.webp" alt="头部添加"></li></ol><h5 id="_2-在尾部插入" tabindex="-1">2.在尾部插入 <a class="header-anchor" href="#_2-在尾部插入" aria-label="Permalink to &quot;2.在尾部插入&quot;">​</a></h5><p>此操作在（双端队列的）后端添加一个元素。</p><ol><li>检查双端队列是否满了</li></ol><p><img src="https://gitee.com/zackzhengxy/picGallery/raw/main/imgs/deque-insert-rear-1.webp" alt="检查双端队列是否满了"></p><ol start="2"><li>如果双端队列已满，则无法执行插入操作（出现溢出情况）。</li><li>如果双端队列是空的，重新初始化<code>rear = 0</code>。并且，添加新值到<code>array[rear]</code></li><li>如果<code>rear = n - 1</code>，重新初始化<code>rear = 0</code>(第一个索引位置)</li><li>否则，<code>rear</code>加1 <img src="https://gitee.com/zackzhengxy/picGallery/raw/main/imgs/deque-insert-rear-2.webp" alt="尾指针自增"></li><li>将新值<code>5</code>添加到<code>array[rear]</code><img src="https://gitee.com/zackzhengxy/picGallery/raw/main/imgs/deque-insert-rear-3.webp" alt="尾部插入"></li></ol><h4 id="_3-从头部删除" tabindex="-1">3.从头部删除 <a class="header-anchor" href="#_3-从头部删除" aria-label="Permalink to &quot;3.从头部删除&quot;">​</a></h4>',22)]))}const g=a(o,[["render",l]]);export{m as __pageData,g as default};
