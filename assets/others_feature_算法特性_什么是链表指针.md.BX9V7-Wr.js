import{_ as i}from"./chunks/theme.BdyS97Bh.js";import{_ as t,c as n,o as l,j as s,G as p,aG as r}from"./chunks/framework.CdnsPyyz.js";const B=JSON.parse('{"title":"什么是链表指针(引用)","description":"","frontmatter":{"title":"什么是链表指针(引用)","author":"Zack Zheng","date":"2025/04/22 13:58","categories":["何以编程"],"tags":["算法","链表"]},"headers":[],"relativePath":"others/feature/算法特性/什么是链表指针.md","filePath":"others/feature/算法特性/什么是链表指针.md","lastUpdated":1745553075000}'),h={name:"others/feature/算法特性/什么是链表指针.md"};function o(d,e,k,_,u,m){const a=i;return l(),n("div",null,[e[0]||(e[0]=s("p",null,"就是区分什么时候是实际修改了链表，什么时候只是链表的引用 我经常写代码写着写着就忘记了，一旦忘记了这个事情，代码就会写乱",-1)),e[1]||(e[1]=s("ul",null,[s("li",null,"首先，链表是引用类型"),s("li",null,"函数传递链表，传递是值类型（也就是指向链表的内存地址副本），也叫什么“引用的副本”"),s("li",null,"对引用类型本身的修改，会影响原链表（也就是修改了链表）"),s("li",null,"什么是本身的修改？链表本身有2个属性，一个是val值，一个是next指针"),s("li",null,"修改了这两个属性，就是修改了链表"),s("li",null,"否则，你只是在移动链表指针（就是移动指向链表的内存地址副本的地址位置），对原链表没有影响")],-1)),e[2]||(e[2]=s("p",null,"看一个实际的代码例子：",-1)),p(a,{src:"https://gitee.com/zackzhengxy/picGallery/raw/main/imgs/链表代码例子.png"}),e[3]||(e[3]=r('<p>这2个函数传入的链表一样，返回的链表也是一样的，下面的函数是利用栈模拟递归，两个函数的功能一样。但是，对传入的链表的操作是不一样的。</p><p>在递归中，可以明显看到</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes one-dark-pro material-theme-palenight vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#E5C07B;--shiki-dark:#BABED8;">head</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">.</span><span style="--shiki-light:#E5C07B;--shiki-dark:#BABED8;">next</span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;"> =</span><span style="--shiki-light:#61AFEF;--shiki-dark:#82AAFF;"> removeNodes1</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">(</span><span style="--shiki-light:#E5C07B;--shiki-dark:#BABED8;">head</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">.</span><span style="--shiki-light:#E5C07B;--shiki-dark:#BABED8;">next</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">)</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这个是修改了链表的next指针，所以传入的链表作为引用类型，实际被修改了</p><p>而在循环中 没有<code>.next = </code>类似的代码，所以传入的原始链表是没有被修改的 为什么没有被修改会返回一个新的链表呢？ 函数内部的压栈操作，操作head指针的地址移动到了null，之后重新连接节点 相当于返回了一个新的链表</p><h4> 以上，规律推广到其他引用类型，判断引用类型是否被修改了，要看引用类型本身的属性是否被修改了 </h4>',6))])}const F=t(h,[["render",o]]);export{B as __pageData,F as default};
