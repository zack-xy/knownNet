import{_ as i,c as a,o as n,aG as l}from"./chunks/framework.DGtm8y85.js";const F=JSON.parse('{"title":"动态规划","description":"","frontmatter":{"title":"动态规划","author":"Zack Zheng","date":"2025/06/05 10:36","categories":["何以编程"],"tags":["算法"]},"headers":[],"relativePath":"others/feature/算法特性/动态规划.md","filePath":"others/feature/算法特性/动态规划.md","lastUpdated":1749114549000}'),h={name:"others/feature/算法特性/动态规划.md"};function k(t,s,p,e,r,D){return n(),a("div",null,s[0]||(s[0]=[l(`<p>动态规划是一种“从底至顶”的方法：从最小子问题的解开始，迭代地构建更大子问题的解，直到得到原问题的解。</p><h6 id="代码示例-爬楼梯问题" tabindex="-1">代码示例：爬楼梯问题 <a class="header-anchor" href="#代码示例-爬楼梯问题" aria-label="Permalink to &quot;代码示例：爬楼梯问题&quot;">​</a></h6><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes one-dark-pro material-theme-palenight vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#676E95;--shiki-dark-font-style:italic;">// 给定一个共有n阶的楼梯，你每步可以上1阶或者2阶，请问有多少种方案可以爬到楼顶？</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C792EA;">public</span><span style="--shiki-light:#C678DD;--shiki-dark:#C792EA;"> int</span><span style="--shiki-light:#61AFEF;--shiki-dark:#82AAFF;"> climbingStairsDP</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">(</span><span style="--shiki-light:#C678DD;--shiki-dark:#C792EA;">int</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;"> n</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">)</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-light-font-style:inherit;--shiki-dark:#89DDFF;--shiki-dark-font-style:italic;">  if</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;"> (</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;">n </span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">==</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;"> 1</span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;"> ||</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;"> n </span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">==</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;"> 2</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">)</span><span style="--shiki-light:#C678DD;--shiki-light-font-style:inherit;--shiki-dark:#89DDFF;--shiki-dark-font-style:italic;"> return</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;"> n</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#676E95;--shiki-dark-font-style:italic;">  // 初始化dp表，用于存储子问题的解</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C792EA;">  int</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">[]</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;"> dp </span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">=</span><span style="--shiki-light:#C678DD;--shiki-light-font-style:inherit;--shiki-dark:#89DDFF;--shiki-dark-font-style:italic;"> new</span><span style="--shiki-light:#C678DD;--shiki-dark:#C792EA;"> int</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">[</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;">n</span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">+</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;">1</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">]</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#676E95;--shiki-dark-font-style:italic;">  // 初始状态：预设最小子问题的解</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;">  dp</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">[</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;">1</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">]</span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;"> =</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;"> 1</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;">  dp</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">[</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;">2</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">]</span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;"> =</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;"> 2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#676E95;--shiki-dark-font-style:italic;">  // 状态转移：从较小子问题逐步求解较大子问题</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-light-font-style:inherit;--shiki-dark:#89DDFF;--shiki-dark-font-style:italic;">  for</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;"> (</span><span style="--shiki-light:#C678DD;--shiki-dark:#C792EA;">int</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;"> i</span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">=</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;">3</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;">i</span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">&lt;=</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;">n</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;">i</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">++</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">)</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;">    dp</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">[</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;">i</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">]</span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">=</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;">dp</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">[</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;">i</span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">-</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;">1</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">]</span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">+</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;">dp</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">[</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;">i</span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">-</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;">2</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">]</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">  }</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-light-font-style:inherit;--shiki-dark:#89DDFF;--shiki-dark-font-style:italic;">  return</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;"> dp</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">[</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;">n</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">]</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h6 id="常见术语" tabindex="-1">常见术语 <a class="header-anchor" href="#常见术语" aria-label="Permalink to &quot;常见术语&quot;">​</a></h6><ul><li>将数组<code>dp</code>称为dp表，dp[i]表示状态i对应子问题的解</li><li>将最小子问题对应的状态(第1阶和第2阶楼梯)称为<code>初始状态</code></li><li>将递推公式<code>dp[i]=dp[i-1]+dp[i-2]</code>称为<code>状态转移方程</code></li></ul><h6 id="空间优化" tabindex="-1">空间优化 <a class="header-anchor" href="#空间优化" aria-label="Permalink to &quot;空间优化&quot;">​</a></h6><p>因为dp[i]只与dp[i-1]和dp[i-2]有关，所以可以只用两个变量来存储这两个值，从而节省空间。</p><p>（这种空间优化技巧称为“滚动变量”或“”）</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes one-dark-pro material-theme-palenight vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#676E95;--shiki-dark-font-style:italic;">// 空间优化后的代码示例</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C792EA;">public</span><span style="--shiki-light:#C678DD;--shiki-dark:#C792EA;"> int</span><span style="--shiki-light:#61AFEF;--shiki-dark:#82AAFF;"> climbingStairsDPComp</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">(</span><span style="--shiki-light:#C678DD;--shiki-dark:#C792EA;">int</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;"> n</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">)</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-light-font-style:inherit;--shiki-dark:#89DDFF;--shiki-dark-font-style:italic;">  if</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;"> (</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;">n </span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">==</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;"> 1</span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;"> ||</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;"> n </span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">==</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;"> 2</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">)</span><span style="--shiki-light:#C678DD;--shiki-light-font-style:inherit;--shiki-dark:#89DDFF;--shiki-dark-font-style:italic;"> return</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;"> n</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#7F848E;--shiki-light-font-style:italic;--shiki-dark:#676E95;--shiki-dark-font-style:italic;">  // 用两个变量存储前两个状态的解</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C792EA;">  int</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;"> a </span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">=</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;"> 1</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">,</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;"> b </span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">=</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;"> 2</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-light-font-style:inherit;--shiki-dark:#89DDFF;--shiki-dark-font-style:italic;">  for</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;"> (</span><span style="--shiki-light:#C678DD;--shiki-dark:#C792EA;">int</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;"> i</span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">=</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;">3</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;">i</span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">&lt;=</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;">n</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;">i</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">++</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">)</span><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#C792EA;">    int</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;"> tmp </span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">=</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;"> b</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;">    b </span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">=</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;"> a </span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">+</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;"> b</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;">    a </span><span style="--shiki-light:#56B6C2;--shiki-dark:#89DDFF;">=</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;"> tmp</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">  }</span></span>
<span class="line"><span style="--shiki-light:#C678DD;--shiki-light-font-style:inherit;--shiki-dark:#89DDFF;--shiki-dark-font-style:italic;">  return</span><span style="--shiki-light:#E06C75;--shiki-dark:#BABED8;"> b</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#E06C75;--shiki-dark:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h6 id="动态规划和分治、回溯的区别" tabindex="-1">动态规划和分治、回溯的区别 <a class="header-anchor" href="#动态规划和分治、回溯的区别" aria-label="Permalink to &quot;动态规划和分治、回溯的区别&quot;">​</a></h6><ul><li>分治：递归地将原问题划分为多个<code>相互独立的子问题</code>,直至最小子问题，并在回溯中合并子问题的解，最终得到原子问题的解</li><li>回溯：在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。<code>原问题的解由一系列决策步骤构成</code>，可以将每个决策步骤之前的子序列看作一个子问题</li><li>动态规划：动态规划中的<code>子问题是相互依赖的</code>,在分解过程中会出现许多重叠子问题</li></ul><h6 id="动态规划特性" tabindex="-1">动态规划特性 <a class="header-anchor" href="#动态规划特性" aria-label="Permalink to &quot;动态规划特性&quot;">​</a></h6><ul><li><code>最优子结构</code><br> （原问题的最优解是从子问题的最优解构建得来的）<br> （在上面的爬楼梯的例子中，其实就是在求上n阶楼梯的最大方案数量，而求上n阶楼梯的最大方案数量是可以从子问题的最优解，也就是求n-1阶和n-2阶楼梯的最大方案数量中构建得来）</li><li><code>无后效性</code><br><b>给定一个确定的状态，它的未来发展只与当前状态有关，而与过去经历的所有状态无关。</b><br> （无后效性指当前状态确定后，后续决策仅与当前状态值有关，而与如何到达该状态的路径无关）<br> （在爬楼梯的例子里，给定状态i，会发展出状态i+1和状态i+2,在做出这两种选择时，无须考虑状态i之前的状态，它们对状态i的未来没有影响）<br> (举一个反例：给定一个共有n的楼梯，你每步可以上1阶或者2阶。规定当爬到第i阶时，系统自动会在第2i阶上放上障碍物，之后所有轮都不允许跳到第2i阶上。请问有多少中方案可以爬到楼顶？这个问题里，下一次跳跃依赖过去的所有状态，就不满足无后效性了)</li></ul>`,13)]))}const y=i(h,[["render",k]]);export{F as __pageData,y as default};
