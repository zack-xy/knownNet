import{_ as i}from"./chunks/MyCodes.BJDCdYaD.js";import{_ as t,c as o,o as l,aG as r,b as s,w as c,G as n,aH as d}from"./chunks/framework.DsljODgs.js";import"./chunks/theme.nDu8YGQ2.js";const x=JSON.parse('{"title":"堆的性质和概念","description":"","frontmatter":{"title":"堆的性质和概念","author":"Zack Zheng","date":"2025/05/29 10:45","categories":["何以编程"],"tags":["算法","Remote Code"]},"headers":[],"relativePath":"others/feature/算法特性/堆的性质和概念.md","filePath":"others/feature/算法特性/堆的性质和概念.md","lastUpdated":1755154786000}'),h={name:"others/feature/算法特性/堆的性质和概念.md"};function p(u,a,_,m,b,f){const e=i;return l(),o("div",null,[a[0]||(a[0]=r('<h5 id="堆的性质" tabindex="-1">堆的性质 <a class="header-anchor" href="#堆的性质" aria-label="Permalink to &quot;堆的性质&quot;">​</a></h5><ul><li>堆是一种满足特定条件的<a href="./树的概念和性质.html#二叉树类型#完全二叉树">完全二叉树</a> (小顶堆：任意节点的值 &lt;= 其子节点的值；大顶堆：任意节点的值 &gt;= 其子节点的值)</li><li>最底层节点靠左填充，其他层节点都被填满（完全二叉树的性质）</li><li>对于大顶堆（小顶堆），堆顶元素（根节点）的值是最大（最小）的</li></ul><div class="info custom-block"><p class="custom-block-title">INFO</p><p>许多编程语言提供的是优先队列，堆通常用于实现优先队列，大顶堆相当于元素按从大到小的顺序出队的优先队列 从使用角度来看，可以将“优先队列”和“堆”看作等价的数据结构 在Java中可以认为堆就是优先级队列，优先级队列就是堆，其他语言不行。</p></div><div class="danger custom-block"><p class="custom-block-title">DANGER</p><p>也有不属于完全二叉树的堆，比如二项堆、斐波那契堆</p></div><h5 id="堆的操作" tabindex="-1">堆的操作 <a class="header-anchor" href="#堆的操作" aria-label="Permalink to &quot;堆的操作&quot;">​</a></h5><h6 id="元素入堆" tabindex="-1">元素入堆 <a class="header-anchor" href="#元素入堆" aria-label="Permalink to &quot;元素入堆&quot;">​</a></h6><p>把新加的元素添加到堆底，【从底至顶】执行堆化</p><h6 id="堆顶元素出堆" tabindex="-1">堆顶元素出堆 <a class="header-anchor" href="#堆顶元素出堆" aria-label="Permalink to &quot;堆顶元素出堆&quot;">​</a></h6><ul><li>交换堆顶元素和堆底元素</li><li>删除堆底元素</li><li>【从顶至底】执行堆化</li></ul><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>以下针对大顶堆（小顶堆符号反过来）</p><ul><li>【从底至顶堆化】</li></ul><ol><li>传入堆化节点的索引i</li><li>获取该节点i的父节点索引p<br> 2.1. 如果p&lt;0，说明越过根节点了，堆化停止<br> 2.2. 如果当前节点的值 <code>&lt;</code> 父的值，节点关系不用修复，堆化停止</li><li>否则，交换p节点和i节点的值</li><li>将i更新为p，向上继续堆化（为什么是向上？因为p是父节点索引）</li></ol><ul><li>【从顶至底堆化】</li></ul><ol><li>传入堆化节点的索引i</li><li>获取左子节点索引l和右子节点索引r</li><li>找出l、r，i对应的值中最大的</li><li>如果最大的值是i对应的值，节点关系不用修复，堆化停止</li><li>否则，交换i节点和最大值节点的值</li><li>将i更新为最大值节点的索引，向下继续堆化（为什么是向下，因为i更新为子节点索引）</li></ol></div><h5 id="堆的使用技巧" tabindex="-1">堆的使用技巧 <a class="header-anchor" href="#堆的使用技巧" aria-label="Permalink to &quot;堆的使用技巧&quot;">​</a></h5><p>查找：找(k)大用小(顶堆)，(后序元素比根)大的进(堆)；找小用大，小的进<br> 排序：升序用小，降序用大</p><h5 id="大顶堆代码示例" tabindex="-1">大顶堆代码示例 <a class="header-anchor" href="#大顶堆代码示例" aria-label="Permalink to &quot;大顶堆代码示例&quot;">​</a></h5>',13)),(l(),s(d,null,{default:c(()=>[n(e,{repo:"o-algorithm",path:"dataStructure/堆/MaxHeap.java",lang:"java",lazy:""})]),_:1}))])}const g=t(h,[["render",p]]);export{x as __pageData,g as default};
