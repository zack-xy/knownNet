import{_ as r}from"./chunks/MyCodes.xXgvjKvq.js";import{_ as l,c as o,o as e,aG as i,b as s,w as n,G as _,aH as h}from"./chunks/framework.CdnsPyyz.js";const k=JSON.parse('{"title":"如何设计一个递归函数","description":"","frontmatter":{"title":"如何设计一个递归函数","author":"Zack Zheng","date":"2025/05/19 15:23","categories":["何以编程"],"tags":["算法","递归"]},"headers":[],"relativePath":"others/feature/算法特性/如何设计一个递归函数.md","filePath":"others/feature/算法特性/如何设计一个递归函数.md","lastUpdated":1747643262000}'),c={name:"others/feature/算法特性/如何设计一个递归函数.md"};function d(p,a,u,m,f,b){const t=r;return e(),o("div",null,[a[0]||(a[0]=i('<p>递归，很重要！</p><p>遇到一个问题，容易想到使用递归来做</p><p>但是一个递归函数，到底应该怎么设计呢？</p><h5 id="递归的特征" tabindex="-1">递归的特征 <a class="header-anchor" href="#递归的特征" aria-label="Permalink to &quot;递归的特征&quot;">​</a></h5><ul><li>执行范围不断缩小</li><li>终止条件判断在递归调用之前 （在执行递归之前，一定会有一个终止条件）</li></ul><h5 id="递归三要素" tabindex="-1">递归三要素 <a class="header-anchor" href="#递归三要素" aria-label="Permalink to &quot;递归三要素&quot;">​</a></h5><ol><li>终止条件：用于决定什么时候由“递”转“归”</li><li>递归调用：对应“递”，函数调用自身，通常输入更小或更简化的参数</li><li>返回结果：对应“归”，将当前递归层级的结果返回至上一层</li></ol><h5 id="核心原则" tabindex="-1">核心原则 <a class="header-anchor" href="#核心原则" aria-label="Permalink to &quot;核心原则&quot;">​</a></h5><p>【明确递归状态】</p><p>递归函数的参数的本质是在递归过程中需要维护的状态信息。设计时需要回答：</p><ul><li>当前递归需要知道什么？</li><li>当前递归需要向下传递什么？</li></ul><h6 id="递归解决问题的代码示例" tabindex="-1">递归解决问题的代码示例 <a class="header-anchor" href="#递归解决问题的代码示例" aria-label="Permalink to &quot;递归解决问题的代码示例&quot;">​</a></h6>',12)),(e(),s(h,null,{default:n(()=>[_(t,{repo:"o-algorithm",path:"algorithm/树常见题/路径问题/binaryTreePaths.java",lang:"java"})]),_:1}))])}const q=l(c,[["render",d]]);export{k as __pageData,q as default};
