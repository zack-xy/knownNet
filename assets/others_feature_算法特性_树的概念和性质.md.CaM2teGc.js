import{_ as u}from"./chunks/MyCodes.Dcm4An61.js";import{_}from"./chunks/theme.DiUeXh3q.js";import{_ as p,c as m,o as i,aG as c,G as e,j as l,b as o,w as r,aH as n,a as d}from"./chunks/framework.CdnsPyyz.js";const v=JSON.parse('{"title":"树的概念和性质","description":"","frontmatter":{"title":"树的概念和性质","author":"Zack Zheng","date":"2025/05/13 10:46","categories":["何以编程"],"tags":["算法"]},"headers":[],"relativePath":"others/feature/算法特性/树的概念和性质.md","filePath":"others/feature/算法特性/树的概念和性质.md","lastUpdated":1749437117000}'),h={name:"others/feature/算法特性/树的概念和性质.md"};function f(g,a,b,k,x,T){const s=_,t=u;return i(),m("div",null,[a[0]||(a[0]=c('<h5 id="常见术语" tabindex="-1">常见术语 <a class="header-anchor" href="#常见术语" aria-label="Permalink to &quot;常见术语&quot;">​</a></h5><ul><li><code>根节点</code>：位于二叉树顶层的节点，没有父节点</li><li><code>叶节点</code>：没有子节点的节点（度为0的节点），其两个指针均指向None</li><li>森林：由m(m&gt;0)棵互不相交的树的集合</li><li>无序树：树中任意节点的子节点之间没有顺序关系</li><li>有序树：树中任意节点的子节点之间有顺序关系</li><li>二叉树：每个节点最多含有2个子树的树</li><li><code>边</code>：连接两个节点的线段，即节点引用(指针)</li><li>节点所在的<code>层</code>:从顶到底递增，根节点所在的层为1</li><li>节点的<code>度</code>:节点的子节点的数量。在二叉树中，度的取值范围是0、1、2</li><li>树的<code>度</code>: 一棵树中，最大的节点的度称为树的度</li><li>二叉树的<code>高度</code>:从根节点到最远叶节点所经过的边的数量</li><li>节点的<code>深度</code>:从根节点到该节点所经过的边的数量</li><li>树的<code>深度</code>:从根节点到树中最深叶子节点的最长路径上的节点数(只有根节点的树深度为1)</li><li>节点的<code>高度</code>:从距离该节点最远的叶节点到该节点所经过的边的数量</li></ul><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>上面这个高度和深度，具体是以边来计算还是以节点来计算，似乎不太一致。 但都是从1开始计算的</p><p><code>高度的计算是从山脚开始往上量的</code><br><code>深度的计算是从山顶开始往下量的</code></p></div><h6 id="演示图" tabindex="-1">演示图 <a class="header-anchor" href="#演示图" aria-label="Permalink to &quot;演示图&quot;">​</a></h6>',4)),e(s,{src:"https://gitee.com/zackzhengxy/picGallery/raw/main/imgs/树的演示图001.jpeg"}),a[1]||(a[1]=c('<h5 id="二叉树类型" tabindex="-1">二叉树类型 <a class="header-anchor" href="#二叉树类型" aria-label="Permalink to &quot;二叉树类型&quot;">​</a></h5><ul><li>完美二叉树(满二叉树)：除了叶子节点，其他节点度都为2</li><li>完全二叉树：只有叶子节点没填满，且叶子节点都靠最左</li><li>完满二叉树：除了叶子节点，其他节点都有2个节点（没有度为1的节点）</li><li>平衡二叉树：任意节点左子树和右子树高度差绝对值不超过1</li><li>二叉搜索树：任意节点满足左子树中所有节点的值&lt;父节点的值&lt;右子树中所有节点的值</li><li>AVL树（平衡二叉搜索树）：即是平衡二叉树又是二叉搜索树</li><li>红黑树</li><li>B树(不是二叉树)</li><li>B+树(不是二叉树)</li></ul><h5 id="二叉树的性质" tabindex="-1">二叉树的性质 <a class="header-anchor" href="#二叉树的性质" aria-label="Permalink to &quot;二叉树的性质&quot;">​</a></h5>',3)),e(s,{src:"https://gitee.com/zackzhengxy/picGallery/raw/main/imgs/树的性质.png"}),a[2]||(a[2]=l("p",null,"数组表示下的二叉树",-1)),(i(),o(n,null,{default:r(()=>[e(t,{repo:"o-algorithm",path:"dataStructure/树/ArrayBinaryTree.java",lang:"java",lazy:""})]),_:1})),a[3]||(a[3]=l("h5",{id:"树的遍历",tabindex:"-1"},[d("树的遍历 "),l("a",{class:"header-anchor",href:"#树的遍历","aria-label":'Permalink to "树的遍历"'},"​")],-1)),a[4]||(a[4]=l("h6",{id:"广度优先-层序遍历",tabindex:"-1"},[d("广度优先（层序遍历） "),l("a",{class:"header-anchor",href:"#广度优先-层序遍历","aria-label":'Permalink to "广度优先（层序遍历）"'},"​")],-1)),a[5]||(a[5]=l("p",null,"借助“队列”实现",-1)),(i(),o(n,null,{default:r(()=>[e(t,{repo:"o-algorithm",path:"dataStructure/树/binary_tree_bfs.java",lang:"java",lazy:""})]),_:1})),a[6]||(a[6]=l("h6",{id:"深度优先",tabindex:"-1"},[d("深度优先 "),l("a",{class:"header-anchor",href:"#深度优先","aria-label":'Permalink to "深度优先"'},"​")],-1)),a[7]||(a[7]=l("p",null,"基于“递归”实现",-1)),a[8]||(a[8]=l("ul",null,[l("li",null,"前序遍历：中左右"),l("li",null,"中序遍历：左中右"),l("li",null,"后续遍历：左右中")],-1)),(i(),o(n,null,{default:r(()=>[e(t,{repo:"o-algorithm",path:"dataStructure/树/binary_tree_dfs.java",lang:"java",lazy:""})]),_:1}))])}const N=p(h,[["render",f]]);export{v as __pageData,N as default};
