import{_ as a,c as e,o as i,aG as t}from"./chunks/framework.CAL16D-w.js";const o=JSON.parse('{"title":"关于可编辑内容元素","description":"","frontmatter":{"title":"关于可编辑内容元素","lang":"en-US","date":"2023/06/08 00:00:00","editLink":true,"categories":["困难冲冲"],"tags":["需求","工作日常"]},"headers":[],"relativePath":"program/issues/关于可编辑内容元素.md","filePath":"program/issues/关于可编辑内容元素.md","lastUpdated":1755156517000}'),p={name:"program/issues/关于可编辑内容元素.md"};function n(r,s,l,h,d,k){return i(),e("div",null,[...s[0]||(s[0]=[t(`<p>小兄弟需要实现一个下划线可编辑的功能<br> 比如说____________ 这个下划线展示文字，文字可编辑</p><p>我之前刚优化音转字的功能，恰巧也有一个录音文字编辑的功能，与其类似</p><p>我建议他使用contenteditable属性，使标签内容可编辑 同时去除激活时的边框</p><div class="language-css vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes one-dark-pro material-theme-palenight vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#C678DD;--shiki-dark:#89DDFF;">[</span><span style="--shiki-light:#D19A66;--shiki-dark:#C792EA;">contenteditable</span><span style="--shiki-light:#C678DD;--shiki-dark:#89DDFF;">]</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;"> {</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#B2CCD6;">    outline</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">:</span><span style="--shiki-light:#D19A66;--shiki-dark:#F78C6C;"> 0</span><span style="--shiki-light:#E06C75;--shiki-dark:#F78C6C;">px</span><span style="--shiki-light:#D19A66;--shiki-dark:#BABED8;"> solid</span><span style="--shiki-light:#D19A66;--shiki-dark:#BABED8;"> transparent</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">;</span></span>
<span class="line"><span style="--shiki-light:#ABB2BF;--shiki-dark:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>小兄弟坚持自己的选择，采用input模拟，去掉其他边框，保留下边框<br> 我刚开始觉得也行吧，反正功能也能实现<br> 只是觉得为了实现输入文字，下划线跟随的功能，他在实时计算字数，给input宽度很丑陋</p><p>上线后，在迭代的过程中，发现文字过多时，不会换行就超出页面(之前那些可编辑的地儿都是短文字)</p><p>突然之间，发觉不可迭代了</p><p>我第一想法是为了减少变更，就换成textarea模拟，换行可以解决</p><p>但是textarea不能自动适应文字的高度，问题变成了如何使textarea自适应高度</p><p>计算字数自然不行</p><p>遂去找解决方案</p><p>canvas中的measureText确实没想到</p><p><a href="https://juejin.cn/post/7258337246024613943" target="_blank" rel="noreferrer">https://juejin.cn/post/7258337246024613943</a></p><p>照着实现了下，倒是基本可以，但是确实是算不准，最后还是放弃了</p><p>所以，设计之前，还是要考虑好不同的情况，设计有什么缺陷，尤其是代码明显很丑陋的时候，往往就是选用的方式是错误的，良好的设计和实现必然是优雅的</p>`,15)])])}const c=a(p,[["render",n]]);export{o as __pageData,c as default};
