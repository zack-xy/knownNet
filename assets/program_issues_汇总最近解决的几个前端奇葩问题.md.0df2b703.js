import{_ as e,c as t,o,a as s}from"./app.c48905b3.js";const b=JSON.parse('{"title":"汇总最近解决的几个前端奇葩问题","description":"","frontmatter":{"title":"汇总最近解决的几个前端奇葩问题","lang":"en-US","date":"2023/06/08 00:00:00","editLink":true,"categories":["困难冲冲"],"tags":["需求"]},"headers":[],"relativePath":"program/issues/汇总最近解决的几个前端奇葩问题.md","lastUpdated":1740468438000}'),p={name:"program/issues/汇总最近解决的几个前端奇葩问题.md"},r=s('<p>一般奇葩的问题，原因往往是最简单的，就让人很无语<br> 也说明，代码为何需要规范，为什么需要看好的范例。因为很多情况下，有些人根本不知道自己在写什么，为什么这么写，包括我自己</p><ol><li>生产有人反馈，弹出的dialog弹窗，无法滚动，导致无法展示超出的部分，则无法继续操作</li></ol><p>经检查，发现mac电脑（开发电脑）是可以的，windows电脑有这个bug，同一个页面的其他弹窗可以正常滚动，就某2个按钮弹出的弹窗在windows电脑上无法滚动</p><p>遂去排查代码，页面元素比较多，层叠了大概3-4个滚动条，首先怀疑滚动条被禁用了，调整偏移弹窗，可以发现，滚动条是出现的，但是鼠标在上面操作没反应，第一反应是某层透明元素遮住了目标元素。调整z-index，无效，移动元素位置，无效。遂比较正常的弹窗和非正常的弹窗，检查css，立即发现了pointer-events:none，检查发现这个一个穿透样式，人为定义在了.el-dialog__wrapper上，导致事件向下穿透，无法响应</p><ol start="2"><li>H5端，给后端的传参数会被浏览器自动改写</li></ol><p>这是一个跳转的H5页面，参数由url携带，初始化后，会将参数，假设id=1111111111保存到sessionStorage中，前置的几个接口传递都是正常的，但是到某一个页面之后，sessionStorage保存的参数仍旧是1111111111，但是接口传递为1111111100，后4位自动变成了0，出错的页面第一次进入，还是传对的，再次刷新传错。</p><p>之前功能是测过的，没有问题 本地也无法复现 调试代码，无果，因为代码很简单，取值传递，没有处理 更换node打包，浏览器版本，无果 后突然意识到，该值为数字，可能超出了js最大安全数字 检查一下，果然如此，后端之前生成的url参数在安全数字之内 后未经测试，直接修改了长度，增加了4位，导致超出</p><ol start="3"><li>IOS从下弹出的组件，位置错误</li></ol><p>同事寻求帮助，他使用的是某赞的UI组件，在安卓弹出正常，在IOS中，某2个页面弹出位置不对，页面下方留有空白。</p><p>首先怀疑，页面下方是否由元素占位，检查之，没有 怀疑是否是组件配置不对，因为我也没有看过组件的文档，由他修改几个若干配置，无果 检查其代码，发现其组件的嵌套似乎不对，令其移除嵌套，解决之</p><ol start="4"><li>页面突发错乱或按钮位置移动位置</li></ol><p>这个很好理解，必然是出现了不应该出现的CSS 意外之外出现的css，最常见的就是写组件不加scoped，导致溢出</p><ol start="5"><li>组件渲染出错</li></ol><p>同事的问题，写了2个相同的组件，Vue就地复用，导致渲染异常，增加一个key，问题解决</p><ol start="6"><li>上传文件，随机失败后几个</li></ol><p>上传文件对接的是内部开发的服务，调用服务是正常的，但我们后端这里及前端这里会随机失败后几个文件，有时2个，有时3个，有时1个，控制台也没报错，百思不解。后发现，上一个开发，使用的v-if处理上传组件的显示，如果多个文件上传完毕，则会销毁上传组件。然而，上传组件上有事件触发，这个事件触发是通知我们后端，上传完成文件的id。因为v-if销毁了组件，导致组件的事件触发无了。改成v-show，问题解决</p><ol start="7"><li>上传文件失败，本地可以上传到测试环境，测试环境的无法上传</li></ol><p>没错，还是上面那个上传服务，某同事新建的一个后管项目，不知道从哪copy过来的一个项目。<br> 起初他是怀疑提供的上传的SDKjs中有没有覆盖到的bug，那这属于另一个团队的事情<br> 我感觉应该不是，因为无法解释为什么同一个SDKjs，本地是可以的<br> 因为调用上传的API已经是上线过的了，在另外若干项目中都是使用正常的<br> 他也是从另外几个正常的项目中copy出来的封装，不存在写错的问题<br> 排除了node版本，安装包版本，浏览器问题<br> 没办法，我只能去sdk里去调试对比<br> 经排查，他copy的项目里有某个js改了XMLRequest导致SDK上传中new出来得实例不对<br> 查看调用栈，是某个打包后的index.js，进入查看，发现里面有一些Mock代码的打包。<br> 不确定，继续调试，发现调用此js前，调用栈里是MOCK的调用，怀疑Mock修改了请求<br> 注释Mock，问题解决</p><ol start="8"><li>接入某SDK（自研的）A后，某工具箱SDK（自研的跳验证码之类的）B干坏了<br> 二者均是压缩后的js，可想而知，多么难看，我多么崩溃</li></ol><p>我去排查，层层筛选</p><p>发现某SDK A拦截修改了window.fetch，这个是它应有的功能</p><p>另一个某工具箱SDK B，发了一个请求，这里报错了</p><p>请求它封装了，做了若干操作，最后需要.then.then.then</p><p>某SDK A拦截修改的window.fetch只做了call调用，并没有return，那B还链式then个屁，指定报错啦</p><p>修改压缩后的sdk代码，找到相应行，加一个return，问题解决</p>',25),l=[r];function i(a,_,n,c,d,S){return o(),t("div",null,l)}const g=e(p,[["render",i]]);export{b as __pageData,g as default};
