import{_ as e,c as o,o as r,aG as t}from"./chunks/framework.DsljODgs.js";const f=JSON.parse('{"title":"V8内存及垃圾回收机制","description":"","frontmatter":{"title":"V8内存及垃圾回收机制","author":"Zack Zheng","date":"2023/09/01 00:00","categories":["浏览器"],"tags":["浏览器","读书笔记"]},"headers":[],"relativePath":"program/pieces/V8内存及垃圾回收机制.md","filePath":"program/pieces/V8内存及垃圾回收机制.md","lastUpdated":1741325738000}'),i={name:"program/pieces/V8内存及垃圾回收机制.md"};function d(h,a,l,c,n,s){return r(),o("div",null,[...a[0]||(a[0]=[t('<h4 id="v8引擎占用的内存-64位机大概1-4g-32位机大概700多mb-实际比这大" tabindex="-1">V8引擎占用的内存，64位机大概1.4G，32位机大概700多MB，实际比这大 <a class="header-anchor" href="#v8引擎占用的内存-64位机大概1-4g-32位机大概700多mb-实际比这大" aria-label="Permalink to &quot;V8引擎占用的内存，64位机大概1.4G，32位机大概700多MB，实际比这大&quot;">​</a></h4><h4 id="内存分为新生代和老生代" tabindex="-1">内存分为新生代和老生代 <a class="header-anchor" href="#内存分为新生代和老生代" aria-label="Permalink to &quot;内存分为新生代和老生代&quot;">​</a></h4><h4 id="新生代很小大概32mb-存临时数据-老生代存长期数据" tabindex="-1">新生代很小大概32MB，存临时数据，老生代存长期数据 <a class="header-anchor" href="#新生代很小大概32mb-存临时数据-老生代存长期数据" aria-label="Permalink to &quot;新生代很小大概32MB，存临时数据，老生代存长期数据&quot;">​</a></h4><h4 id="新生代内存分为from和to-回收算法是-从from复制还活着的变量到to-然后对调from和to" tabindex="-1">新生代内存分为from和to，回收算法是，从from复制还活着的变量到to，然后对调from和to <a class="header-anchor" href="#新生代内存分为from和to-回收算法是-从from复制还活着的变量到to-然后对调from和to" aria-label="Permalink to &quot;新生代内存分为from和to，回收算法是，从from复制还活着的变量到to，然后对调from和to&quot;">​</a></h4><h4 id="老生代回收算法-标记死变量-清除变量-清除后留下了内存空位-所以要整理磁盘" tabindex="-1">老生代回收算法：标记死变量，清除变量，清除后留下了内存空位，所以要整理磁盘 <a class="header-anchor" href="#老生代回收算法-标记死变量-清除变量-清除后留下了内存空位-所以要整理磁盘" aria-label="Permalink to &quot;老生代回收算法：标记死变量，清除变量，清除后留下了内存空位，所以要整理磁盘&quot;">​</a></h4><h4 id="什么时候回收-每次执行完代码-发现内存不够的时候" tabindex="-1">什么时候回收？每次执行完代码/发现内存不够的时候 <a class="header-anchor" href="#什么时候回收-每次执行完代码-发现内存不够的时候" aria-label="Permalink to &quot;什么时候回收？每次执行完代码/发现内存不够的时候&quot;">​</a></h4><h4 id="怎么判断一个变量回没回收-全局的等程序执行完-普通变量-没人引用" tabindex="-1">怎么判断一个变量回没回收？全局的等程序执行完/普通变量，没人引用 <a class="header-anchor" href="#怎么判断一个变量回没回收-全局的等程序执行完-普通变量-没人引用" aria-label="Permalink to &quot;怎么判断一个变量回没回收？全局的等程序执行完/普通变量，没人引用&quot;">​</a></h4><h4 id="什么条件从新生代移到老生代-新生代复制后-占超过25-的to空间-对象已经经历一次回收" tabindex="-1">什么条件从新生代移到老生代：新生代复制后，占超过25%的to空间/对象已经经历一次回收 <a class="header-anchor" href="#什么条件从新生代移到老生代-新生代复制后-占超过25-的to空间-对象已经经历一次回收" aria-label="Permalink to &quot;什么条件从新生代移到老生代：新生代复制后，占超过25%的to空间/对象已经经历一次回收&quot;">​</a></h4><h4 id="怎么优化内存-尽量不定义全局变量-定义了及时释放-注意闭包-闭包的变量是不是有可能大小无限增长" tabindex="-1">怎么优化内存:尽量不定义全局变量，定义了及时释放/注意闭包（闭包的变量是不是有可能大小无限增长） <a class="header-anchor" href="#怎么优化内存-尽量不定义全局变量-定义了及时释放-注意闭包-闭包的变量是不是有可能大小无限增长" aria-label="Permalink to &quot;怎么优化内存:尽量不定义全局变量，定义了及时释放/注意闭包（闭包的变量是不是有可能大小无限增长）&quot;">​</a></h4><h5 id="怎么查看内存" tabindex="-1">怎么查看内存 <a class="header-anchor" href="#怎么查看内存" aria-label="Permalink to &quot;怎么查看内存&quot;">​</a></h5><p>浏览器端：<code>window.performance.memory</code> Node端：<code>process.memoryUsage()</code> Node可以手动触发垃圾回收：<code>global.gc</code> Node可以设置新老生代内存：<code>--max-old-space-size、--max-new-space-size</code></p><h4 id="垃圾回收是阻塞式的-中断代码执行" tabindex="-1">垃圾回收是阻塞式的，中断代码执行 <a class="header-anchor" href="#垃圾回收是阻塞式的-中断代码执行" aria-label="Permalink to &quot;垃圾回收是阻塞式的，中断代码执行&quot;">​</a></h4>',12)])])}const _=e(i,[["render",d]]);export{f as __pageData,_ as default};
