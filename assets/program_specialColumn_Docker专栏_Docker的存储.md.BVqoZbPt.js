import{_ as e,c as s,o as i,aG as n}from"./chunks/framework.CdnsPyyz.js";const k=JSON.parse('{"title":"Docker的存储","description":"","frontmatter":{"title":"Docker的存储","author":"Zack Zheng","date":"2025/01/03 14:07","categories":["Docker专栏"],"tags":["Docker"]},"headers":[],"relativePath":"program/specialColumn/Docker专栏/Docker的存储.md","filePath":"program/specialColumn/Docker专栏/Docker的存储.md","lastUpdated":1735892649000}'),p={name:"program/specialColumn/Docker专栏/Docker的存储.md"};function l(r,a,o,t,h,d){return i(),s("div",null,a[0]||(a[0]=[n(`<p>默认情况下，在运行中的容器里创建的文件，被保存在一个可写的容器层</p><ul><li>如果容器被删除了，数据就没有了</li><li>这个可写的容器层和特定的容器绑定，这些数据无法和其他容器共享</li></ul><p>有2种方式做数据的持久化</p><ul><li><p>Data Volume</p><p>由Docker管理，(/var/lib/docker/volumes/Linux)，持久化数据的最好方式</p></li><li><p>Bind Mount</p><p>由用户指定存储的数据具体mount在系统什么位置</p></li></ul><h4 id="data-volume" tabindex="-1">Data Volume <a class="header-anchor" href="#data-volume" aria-label="Permalink to &quot;Data Volume&quot;">​</a></h4><p>比如说在Dockerfile文件中加一行(一个Dockerfile可以有多个VOLUME)</p><div class="language-dockerfile vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">dockerfile</span><pre class="shiki shiki-themes one-dark-pro material-theme-palenight vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#F78C6C;">VOLUME</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#BABED8;"> [</span><span style="--shiki-light:#98C379;--shiki-dark:#C3E88D;">&quot;/app&quot;</span><span style="--shiki-light:#ABB2BF;--shiki-dark:#BABED8;">]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这里的意思是把容器中的/app目录的内容持久化(挂载)到本地磁盘</p><p>如果在启动容器的时候不指定，docker会给VOLUME一个随机的hash名字</p><p>每次启动，都会有一个不一样的VOLUME名字</p><p>如果想要在启动时，使用同一个VOLUME，需要在启动的时候指定VOLUME的名字</p><p><code>docker container run -d -v cron-data:/app my-cron</code></p><p>(这里-v表示VOLUME，cron-data是VOLUME的名字，/app表示是/app这个路径的VOLUME，my-cron是镜像名字 )</p><p>⚠️(Dockerfile文件中也可以不写VOLUME，那就需要启动容器时使用-v指定VOLUME)</p><p>⚠️（使用Data Volume实际持久化在宿主机上的数据直接访问不到，因为是在Linux虚拟机里。如果宿主机是Linux系统中的Docker，可以直接访问到）</p><h4 id="bind-mount" tabindex="-1">Bind Mount <a class="header-anchor" href="#bind-mount" aria-label="Permalink to &quot;Bind Mount&quot;">​</a></h4><p>可以直接指定mac系统中的路径存储数据</p><p><code>docker container run -d -v $(pwd):/app my-cron</code></p><p>（这里-v表示VOLUME，$(pwd)pwd命令显示当前路径、/app表示启动的容器要持久化数据的目录、my-cron是镜像名字 ）</p><h4 id="多个机器之间的容器共享数据" tabindex="-1">多个机器之间的容器共享数据 <a class="header-anchor" href="#多个机器之间的容器共享数据" aria-label="Permalink to &quot;多个机器之间的容器共享数据&quot;">​</a></h4><p>依靠driver</p><p>具体就是nfs、aws或者ssh</p><p>以ssh为例(最简单)，比如说3台Linux机器，ip互通，可以通过SSH相互通信</p><h5 id="安装plugin" tabindex="-1">安装plugin <a class="header-anchor" href="#安装plugin" aria-label="Permalink to &quot;安装plugin&quot;">​</a></h5><p>其中2台机器上安装plugin: <code>vieux/sshfs</code></p><p>安装命令<code>docker plugin install --grant-all-permissions vieux/sshfs </code> \`</p><h5 id="创建volume" tabindex="-1">创建volume <a class="header-anchor" href="#创建volume" aria-label="Permalink to &quot;创建volume&quot;">​</a></h5><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes one-dark-pro material-theme-palenight vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#61AFEF;--shiki-dark:#FFCB6B;">docker</span><span style="--shiki-light:#98C379;--shiki-dark:#C3E88D;"> volume</span><span style="--shiki-light:#98C379;--shiki-dark:#C3E88D;"> create</span><span style="--shiki-light:#D19A66;--shiki-dark:#C3E88D;"> --driver</span><span style="--shiki-light:#98C379;--shiki-dark:#C3E88D;"> vieux/sshfs</span><span style="--shiki-light:#56B6C2;--shiki-dark:#BABED8;"> \\</span></span>
<span class="line"><span style="--shiki-light:#D19A66;--shiki-dark:#C3E88D;">                          -o</span><span style="--shiki-light:#98C379;--shiki-dark:#C3E88D;"> sshcmd=vagrant@192.168.200.12:/home/vagrant</span><span style="--shiki-light:#56B6C2;--shiki-dark:#BABED8;"> \\</span></span>
<span class="line"><span style="--shiki-light:#D19A66;--shiki-dark:#C3E88D;">                          -o</span><span style="--shiki-light:#98C379;--shiki-dark:#C3E88D;"> password=vagrant</span><span style="--shiki-light:#56B6C2;--shiki-dark:#BABED8;"> \\</span></span>
<span class="line"><span style="--shiki-light:#98C379;--shiki-dark:#C3E88D;">                          sshvolume</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>（vieux/sshfs是指定的driver，vagrant是用户名，192.168.200.12是第三台机器的ip，/home/vagrant是机器3的共享数据目录、sshvolume是volume的名字 ）</p><h5 id="创建容器挂载volume" tabindex="-1">创建容器挂载volume <a class="header-anchor" href="#创建容器挂载volume" aria-label="Permalink to &quot;创建容器挂载volume&quot;">​</a></h5><p><code>docker run -it -v sshvolume:/app busybox sh</code></p><p>（在机器1或者2上运行上面容器，在容器中的/app目录中创建文件，机器3也会看到）</p>`,32)]))}const u=e(p,[["render",l]]);export{k as __pageData,u as default};
