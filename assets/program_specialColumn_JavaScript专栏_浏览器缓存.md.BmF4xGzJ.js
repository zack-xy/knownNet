import{_ as e,c as r,o as t,aG as c}from"./chunks/framework.DsljODgs.js";const u=JSON.parse('{"title":"浏览器缓存","description":"","frontmatter":{"title":"浏览器缓存","author":"Zack Zheng","date":"2022/02/16 09:51","categories":["JavaScript专栏"],"tags":["JavaScript"]},"headers":[],"relativePath":"program/specialColumn/JavaScript专栏/浏览器缓存.md","filePath":"program/specialColumn/JavaScript专栏/浏览器缓存.md","lastUpdated":1694091456000}'),i={name:"program/specialColumn/JavaScript专栏/浏览器缓存.md"};function o(h,a,l,s,p,n){return t(),r("div",null,[...a[0]||(a[0]=[c('<h2 id="浏览器缓存" tabindex="-1">浏览器缓存 <a class="header-anchor" href="#浏览器缓存" aria-label="Permalink to &quot;浏览器缓存&quot;">​</a></h2><p>拿缓存的优先级<br> Memory Cache -&gt; Service Worker Cache -&gt; Disk Cache -&gt; HTTP Cache -&gt; Push Cache</p><h3 id="memory-cache" tabindex="-1">Memory Cache <a class="header-anchor" href="#memory-cache" aria-label="Permalink to &quot;Memory Cache&quot;">​</a></h3><p>内存缓存，速度快，和渲染进程关联，tab关闭，内存数据拜拜 Base64图片、体积小的js、css文件一般在Memory Cache</p><h3 id="service-worker-cache" tabindex="-1">Service Worker Cache <a class="header-anchor" href="#service-worker-cache" aria-label="Permalink to &quot;Service Worker Cache&quot;">​</a></h3><p>独立于主线程之外的js线程，无法直接访问DOM，可以实现离线缓存、消息推送和网络代理功能 协议必须时https<br> 生命周期：install、active、worki。一旦install，始终存在，除非主动终止</p><h3 id="disk-cache" tabindex="-1">Disk Cache <a class="header-anchor" href="#disk-cache" aria-label="Permalink to &quot;Disk Cache&quot;">​</a></h3><p>慢一些、体积较大的js、css文件</p><h3 id="http-cache" tabindex="-1">HTTP Cache <a class="header-anchor" href="#http-cache" aria-label="Permalink to &quot;HTTP Cache&quot;">​</a></h3><p>拿缓存的优先级<br> 强缓存 -&gt; 协商缓存</p><h4 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-label="Permalink to &quot;强缓存&quot;">​</a></h4><p>命中强缓存，请求状态码是：200</p><p>利用Expires和Cache-Control字段控制</p><ul><li>命中Expires缓存（是一个时间戳）：浏览器对比本地时间和和这个时间，没超过Expires时间，就不用去请求服务器，使用浏览器缓存（本地内存缓存...）</li><li>问题：浏览器改本地时间，就能绕过缓存（为弥补之，诞生Cache-Control）</li></ul><p>命中Cache-Control：里面规定了一个max-age，是一个数字（时间长度，单位秒），在这段时间里，命中Cache-Control。里面也规定了一个s-maxage，是一个数字，在这段时间里，使用代理服务器（cache CDN）的缓存</p><p>同时有Cache-Control、Expires，以Cache-Control为准，同时有s-maxage、max-age，以s-maxage为准</p><h4 id="不缓存" tabindex="-1">不缓存 <a class="header-anchor" href="#不缓存" aria-label="Permalink to &quot;不缓存&quot;">​</a></h4><p>no-store与no-cache</p><ul><li>no-store就是不应用缓存（包括服务器缓存），每次都请求服务器并响应</li><li>no-cache是不应用浏览器缓存，每次请求去问一下服务器资源过没过期，往协商缓存走</li></ul><h4 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h4><p>每次请求，浏览器都问问服务器，我的资源过期没<br> 服务器说没过期，则资源重定向到浏览器缓存，请求状态码：304</p><p>Last-Modified和Etag</p><ul><li><p>命中Last-Modified：是一个时间戳，服务器放在响应头里，浏览器请求时，会将它作为If-Modified-Since的值再发给服务器，服务器就去对比这个资源的最后修改时间，来判断资源有没有更改，改了则返回新的资源+新的Last-Modified时间戳，没改则返回304命中缓存</p></li><li><p>问题：文件改了，但没有完全改（内容没变化）、光速操作（改文件只用了0.1S，Last-Modified只能以秒为单位计算）。为弥补之，诞生Etag</p></li><li><p>命中Etag：响应头里放一个Etag，根据文件内容计算（耗费服务器性能）出来的编码，请求时，再用If-None-Match字段传给服务器，服务器根据文件内容生成的编码对比瞅改没改</p></li></ul><h3 id="push-cache" tabindex="-1">Push Cache <a class="header-anchor" href="#push-cache" aria-label="Permalink to &quot;Push Cache&quot;">​</a></h3><p>以上都没命中，才到Push Cache 浏览器推送资源给客户端缓存 会话阶段的缓存，session终止，缓存释放 不同页面只要共享一个http2连接，则共享一个Push Cache</p>',25)])])}const m=e(i,[["render",o]]);export{u as __pageData,m as default};
