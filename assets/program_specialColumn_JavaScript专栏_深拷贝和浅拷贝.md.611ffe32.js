import{_ as e,c as a,o as i,a as r}from"./app.2a438807.js";const u=JSON.parse('{"title":"深拷贝和浅拷贝","description":"","frontmatter":{"title":"深拷贝和浅拷贝","author":"Zack Zheng","date":"2022/02/16 09:51","categories":["JavaScript专栏"],"tags":["JavaScript"]},"headers":[{"level":3,"title":"浅拷贝","slug":"浅拷贝","link":"#浅拷贝","children":[]},{"level":3,"title":"深拷贝","slug":"深拷贝","link":"#深拷贝","children":[]}],"relativePath":"program/specialColumn/JavaScript专栏/深拷贝和浅拷贝.md","lastUpdated":1684224278000}'),l={name:"program/specialColumn/JavaScript专栏/深拷贝和浅拷贝.md"},t=r('<h3 id="浅拷贝" tabindex="-1">浅拷贝 <a class="header-anchor" href="#浅拷贝" aria-hidden="true">#</a></h3><h4 id="object-assign" tabindex="-1">object.assign <a class="header-anchor" href="#object-assign" aria-hidden="true">#</a></h4><ul><li><p>浅拷贝</p></li><li><p>不会拷贝对象的继承属性</p></li><li><p>不会拷贝对象的不可枚举属性</p></li><li><p>可以拷贝Symbol属性</p></li></ul><h4 id="扩展运算符" tabindex="-1">扩展运算符 <a class="header-anchor" href="#扩展运算符" aria-hidden="true">#</a></h4><ul><li>浅拷贝</li></ul><h4 id="concat拷贝数组" tabindex="-1">concat拷贝数组 <a class="header-anchor" href="#concat拷贝数组" aria-hidden="true">#</a></h4><ul><li>浅拷贝</li><li>只能拷贝数组</li></ul><h4 id="slice拷贝数组" tabindex="-1">slice拷贝数组 <a class="header-anchor" href="#slice拷贝数组" aria-hidden="true">#</a></h4><ul><li>浅拷贝</li><li>只能拷贝数组</li></ul><h4 id="手写一个浅拷贝" tabindex="-1"><a href="https://github.com/zack-xy/write-js/blob/main/DeepClone/shallowClone.js" target="_blank" rel="noreferrer">手写一个浅拷贝</a> <a class="header-anchor" href="#手写一个浅拷贝" aria-hidden="true">#</a></h4><h3 id="深拷贝" tabindex="-1">深拷贝 <a class="header-anchor" href="#深拷贝" aria-hidden="true">#</a></h3><h4 id="json-stringfy" tabindex="-1">JSON.stringfy <a class="header-anchor" href="#json-stringfy" aria-hidden="true">#</a></h4><ul><li><p>拷贝的对象的值中如果有函数、undefined、symbol 这几种类型，经过 JSON.stringify 序列化之后的字符串中这个键值对会消失；</p></li><li><p>拷贝 Date 引用类型会变成字符串；</p></li><li><p>无法拷贝不可枚举的属性；</p></li><li><p>无法拷贝对象的原型链；</p></li><li><p>拷贝 RegExp 引用类型会变成空对象；</p></li><li><p>对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null；</p></li><li><p>无法拷贝对象的循环应用，即对象成环 (obj[key] = obj)。</p></li></ul><h4 id="深拷贝基础手写递归实现" tabindex="-1"><a href="https://github.com/zack-xy/write-js/blob/main/DeepClone/deepClone-simple.js" target="_blank" rel="noreferrer">深拷贝基础手写递归实现</a> <a class="header-anchor" href="#深拷贝基础手写递归实现" aria-hidden="true">#</a></h4><ul><li>不能拷贝不可枚举属性和Symbol类型</li><li>只针对普通引用类型做递归复制 （数组，正则，日期等 不能正确拷贝）</li><li>无法拷贝对象的循环应用，即对象成环 (obj[key] = obj)</li></ul><h4 id="深拷贝升级手写递归实现" tabindex="-1"><a href="https://github.com/zack-xy/write-js/blob/e9c1b929ddf402fa6e9009485dbcbf2fa68999cc/DeepClone/other2-version.js" target="_blank" rel="noreferrer">深拷贝升级手写递归实现</a> <a class="header-anchor" href="#深拷贝升级手写递归实现" aria-hidden="true">#</a></h4><p>利用Object的getOwnPropertyDescriptors方法可以获得对象的所有属性，以及对应的特性，顺便结合Object的create方法创建一个新对象，并继承传入对象的原型链 。利用WeakMap类型作为Hash表，因为WeakMap是弱引用类型，可以有效防止内存泄漏，作为检测循环引用很有帮助，如果存在循环，则引用直接返回WeakMap存储的值</p><h4 id="其他手写深拷贝" tabindex="-1">其他手写深拷贝 <a class="header-anchor" href="#其他手写深拷贝" aria-hidden="true">#</a></h4><ul><li><p><a href="https://github.com/zack-xy/write-js/blob/e9c1b929ddf402fa6e9009485dbcbf2fa68999cc/DeepClone/common-version.js" target="_blank" rel="noreferrer">简单版本</a></p></li><li><p><a href="https://github.com/zack-xy/write-js/blob/e9c1b929ddf402fa6e9009485dbcbf2fa68999cc/DeepClone/other-version.js" target="_blank" rel="noreferrer">简单版本2</a></p></li></ul>',19),n=[t];function h(c,s,o,d,p,b){return i(),a("div",null,n)}const _=e(l,[["render",h]]);export{u as __pageData,_ as default};
