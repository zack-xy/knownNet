import{_ as e,c as t,o as a,a as r}from"./app.c37902e9.js";const g=JSON.parse('{"title":"渲染与渲染优化","description":"","frontmatter":{"title":"渲染与渲染优化","author":"Zack Zheng","date":"2022/02/16 09:51","categories":["JavaScript专栏"],"tags":["JavaScript"]},"headers":[{"level":3,"title":"客户端渲染","slug":"客户端渲染","link":"#客户端渲染","children":[]},{"level":3,"title":"服务端渲染","slug":"服务端渲染","link":"#服务端渲染","children":[]},{"level":3,"title":"浏览器渲染的过程","slug":"浏览器渲染的过程","link":"#浏览器渲染的过程","children":[]},{"level":3,"title":"回流与重绘","slug":"回流与重绘","link":"#回流与重绘","children":[]},{"level":3,"title":"宏任务与微任务","slug":"宏任务与微任务","link":"#宏任务与微任务","children":[]}],"relativePath":"program/specialColumn/JavaScript专栏/渲染与渲染优化.md","lastUpdated":1694091456000}'),i={name:"program/specialColumn/JavaScript专栏/渲染与渲染优化.md"},l=r('<h3 id="客户端渲染" tabindex="-1">客户端渲染 <a class="header-anchor" href="#客户端渲染" aria-hidden="true">#</a></h3><p>什么是客户端渲染？<br> 服务端会把静态资源给浏览器，浏览器运行一遍js，生成页面 页面的内容，在html源文件找不到（因为js没运行，就没的HTML DOM节点）</p><h3 id="服务端渲染" tabindex="-1">服务端渲染 <a class="header-anchor" href="#服务端渲染" aria-hidden="true">#</a></h3><p>什么是服务端渲染？ 服务器会把完整的html给浏览器，浏览器不必跑一遍js才生成html页面 页面的内容，在html源文件找的到</p><p>服务端渲染不是性能万金油，把浏览器干的活都给服务器了，服务器表示鸭梨山大</p><h3 id="浏览器渲染的过程" tabindex="-1">浏览器渲染的过程 <a class="header-anchor" href="#浏览器渲染的过程" aria-hidden="true">#</a></h3><p>解析HTML（发出外部资源请求【DOM树】）-&gt;<br> 计算样式（加载css与DOM和合并生成render树，伪元素也在这个环节被构建到DOM树中【CSSOM树】）-&gt;<br> 计算图层布局(元素的相对位置、大小信息【布局渲染树】) -&gt;<br> 绘制图层（把每一个页面图层转换为像素，对所有媒体文件进行解码）-&gt;<br> 整合图层，得到页面(合并各个图层，将数据由CPU输出给GPU绘制于屏幕上【绘制渲染树】)</p><h4 id="css渲染优化点" tabindex="-1">CSS渲染优化点 <a class="header-anchor" href="#css渲染优化点" aria-hidden="true">#</a></h4><p>CSS引擎查找样式规则，是从右到左匹配的</p><ol><li>避免使用通配符（会遍历每一个元素）</li><li>关注可以通过继承实现的属性，避免重复匹配重复定义</li><li>少用标签选择器（#app li{} -&gt; .app-li {}）</li><li>减少嵌套。后代选择器开销最高，深度最好不超过3层</li></ol><h4 id="关于阻塞的优化" tabindex="-1">关于阻塞的优化 <a class="header-anchor" href="#关于阻塞的优化" aria-hidden="true">#</a></h4><p>HTML、CSS、JS都具有阻塞渲染的特性</p><p>浏览器在构建CSSOM的过程中，不会渲染任何已处理的内容，哪怕DOM已经OK了</p><p><strong>所以CSS是阻塞渲染的资源，需要尽早(css放在head中)尽快(CDN静态资源服务)的下载到客户端</strong></p><p>JS引擎独立于渲染引擎，HTML解析器遇到script标签时，暂停渲染过程，将控制权交给JS引擎，JS引擎对内联代码直接执行，外部JS则去下载，在执行，等JS引擎运行完毕，浏览器才会把控制权交给渲染引擎</p><ul><li>一般情况<br><code>&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</code>阻塞浏览器，需要等index.js加载和执行完毕</li><li>async <code>&lt;script async src=&quot;index.js&quot;&gt;&lt;/script&gt;</code>加载是异步的，加载后，脚本立即执行</li><li>defer <code>&lt;script defer src=&quot;index.js&quot;&gt;&lt;/script&gt;</code>加载是异步的，执行也是推迟的，执行在整个文档解析完成，DOMContentLoaded事件即将被触发时</li></ul><h3 id="回流与重绘" tabindex="-1">回流与重绘 <a class="header-anchor" href="#回流与重绘" aria-hidden="true">#</a></h3><h4 id="回流" tabindex="-1">回流 <a class="header-anchor" href="#回流" aria-hidden="true">#</a></h4><ul><li>回流（重排）：对DOM的修改引起了DOM几何尺寸的变化，比如大小、宽高、是否隐藏等，浏览器需要重新计算元素的几何属性，然后再绘制出来，这个过程称为回流</li><li>重绘：修改了DOM的样式，但没有影响几何属性，比如修改了颜色，浏览器重绘即可 <strong>重绘不一定回流，回流一定重绘</strong></li></ul><p>这两个都应该减少，即减少DOM操作<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment" target="_blank" rel="noreferrer">DocumentFragment</a>则是这个思想，它不是真实DOM树的一部分，对它修改不会引起回流和重绘，操作完DocumentFragment再统一做一次DOM的操作</p><p>引起回流：<br> 1.改变几何属性width、padding、margin、left、boder等<br> 2.改变DOM树结构，节点的增减和移动（开销还凑合）<br> 3.获取offsetTop、scollTop、clientTop等，因为需要即时计算得到，会回流<br> 4.getComputedStyle，也是即时计算得到，会回流</p><p>避免回流：<br> 1.不要在循环里，多次获取offsetTop值，可以缓存在外面，计算完再一次性设置<br> 2.不要逐条修改样式，可以合并作为一个类名，统一修改<br> 3.将DOM离线，设置为display：none，再操作（频繁操作的话可以使用）</p><p>浏览器并不是在每一次修改都会回流，浏览器维护了一个flush队列，只有在不得已的时候才会回流（比如获取即时性属性）</p><h3 id="宏任务与微任务" tabindex="-1">宏任务与微任务 <a class="header-anchor" href="#宏任务与微任务" aria-hidden="true">#</a></h3><p>宏任务：setTimeout、setInterval、setImmediate、script整体代码、I/O操作、UI渲染 微任务：process.nextTick、Promise、MutataionObserver等</p><p>异步任务中进行DOM更新，需要包装为微任务</p>',26),s=[l];function d(n,c,o,p,h,u){return a(),t("div",null,s)}const m=e(i,[["render",d]]);export{g as __pageData,m as default};
