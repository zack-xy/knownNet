import{_ as r}from"./chunks/theme.IrR8Cc8t.js";import{_ as o,c as t,o as i,aG as l,G as c}from"./chunks/framework.DGtm8y85.js";const b=JSON.parse('{"title":"Java堆区方法区永久代的解释","description":"","frontmatter":{"title":"Java堆区方法区永久代的解释","author":"Zack Zheng","date":"2023/02/16 09:51","categories":["Java专栏"],"tags":["Java"]},"headers":[],"relativePath":"program/specialColumn/Java专栏/Java堆区方法区永久代的解释.md","filePath":"program/specialColumn/Java专栏/Java堆区方法区永久代的解释.md","lastUpdated":1749458346000}'),n={name:"program/specialColumn/Java专栏/Java堆区方法区永久代的解释.md"};function d(s,a,_,p,m,u){const e=r;return i(),t("div",null,[a[0]||(a[0]=l('<h5 id="java程序内存划分" tabindex="-1">Java程序内存划分 <a class="header-anchor" href="#java程序内存划分" aria-label="Permalink to &quot;Java程序内存划分&quot;">​</a></h5><h6 id="线程私有" tabindex="-1">线程私有 <a class="header-anchor" href="#线程私有" aria-label="Permalink to &quot;线程私有&quot;">​</a></h6><ul><li>程序计数器<br> 记录当前线程执行的字节码指令地址，唯一无OOM(OutOfMemoryError)区域<br> Java方法执行时：存储指令地址<br> Native方法执行时：值为undefined</li><li>Java虚拟机栈<br> 存储方法调用的栈帧（局部变量表，操作数栈等）</li><li>本地方法栈<br> JVM调用Native方法服务，功能类似虚拟机栈</li></ul><h6 id="线程共享" tabindex="-1">线程共享 <a class="header-anchor" href="#线程共享" aria-label="Permalink to &quot;线程共享&quot;">​</a></h6><ul><li><p>堆<br> 存储对象实例和数组，是垃圾回收的主要区域<br><code>新生代</code>: 包括Eden区和两个Survivor区(s0/s1)，使用复制算法回收<br><code>老生代</code>: 存放长期存活对象，采用标记-整理算法</p></li><li><p>方法区<br> 存储类信息、常量、静态变量等<br><code>JDK 7及之前</code>: 永久代实现<br><code>JDK 8+</code>: 元空间替代，使用本地内存</p></li><li><p>运行时常量池<br> 方法区的一部分，存放编译期生成的常量</p></li></ul><h6 id="直接内存" tabindex="-1">直接内存 <a class="header-anchor" href="#直接内存" aria-label="Permalink to &quot;直接内存&quot;">​</a></h6><p>通过NIO的<code>ByteBuffer.allocateDirect()</code>分配，不受JVM堆限制<br> 需手动管理，溢出时抛出<code>OutOfMemoryError: Direct buffer memory</code></p>',7)),c(e,{src:"https://gitee.com/zackzhengxy/picGallery/raw/main/imgs/Java堆区方法区永久代的解释.png"})])}const J=o(n,[["render",d]]);export{b as __pageData,J as default};
