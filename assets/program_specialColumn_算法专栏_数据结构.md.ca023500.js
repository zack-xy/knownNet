import{_ as l,c as i,o as e,a}from"./app.3d6e69c7.js";const _=JSON.parse('{"title":"常见基本数据结构","description":"","frontmatter":{"title":"常见基本数据结构","author":"Zack Zheng","date":"2022/11/09 00:00","categories":["算法专栏"],"tags":["算法"]},"headers":[{"level":2,"title":"线性表(链表)","slug":"线性表-链表","link":"#线性表-链表","children":[{"level":3,"title":"增、删是O(1)，查询O(n)","slug":"增、删是o-1-查询o-n","link":"#增、删是o-1-查询o-n","children":[]},{"level":3,"title":"价值","slug":"价值","link":"#价值","children":[]},{"level":3,"title":"受限制的线性表","slug":"受限制的线性表","link":"#受限制的线性表","children":[]}]},{"level":2,"title":"数组","slug":"数组","link":"#数组","children":[{"level":3,"title":"按顺序存储数据，存储数据的内存是连续的","slug":"按顺序存储数据-存储数据的内存是连续的","link":"#按顺序存储数据-存储数据的内存是连续的","children":[]},{"level":3,"title":"查找O(1),删除O(n)，增加(最后插入O(1),其他挪动数组O(n))","slug":"查找o-1-删除o-n-增加-最后插入o-1-其他挪动数组o-n","link":"#查找o-1-删除o-n-增加-最后插入o-1-其他挪动数组o-n","children":[]}]},{"level":2,"title":"字符串","slug":"字符串","link":"#字符串","children":[{"level":3,"title":"有顺序存储(定长数组)和链式存储(一个节点存多个字符)两种","slug":"有顺序存储-定长数组-和链式存储-一个节点存多个字符-两种","link":"#有顺序存储-定长数组-和链式存储-一个节点存多个字符-两种","children":[]},{"level":3,"title":"字符串的插入，涉及挪移，时间复杂度O(n)","slug":"字符串的插入-涉及挪移-时间复杂度o-n","link":"#字符串的插入-涉及挪移-时间复杂度o-n","children":[]},{"level":3,"title":"【常见问题】","slug":"【常见问题】","link":"#【常见问题】","children":[]}]},{"level":2,"title":"树","slug":"树","link":"#树","children":[{"level":3,"title":"链表存储","slug":"链表存储","link":"#链表存储","children":[]},{"level":3,"title":"二叉树的类型和遍历","slug":"二叉树的类型和遍历","link":"#二叉树的类型和遍历","children":[]},{"level":3,"title":"【常见问题】","slug":"【常见问题】-1","link":"#【常见问题】-1","children":[]}]},{"level":2,"title":"Hash表（散列表）","slug":"hash表-散列表","link":"#hash表-散列表","children":[{"level":3,"title":"设计Hash函数","slug":"设计hash函数","link":"#设计hash函数","children":[]},{"level":3,"title":"如何解决hash冲突","slug":"如何解决hash冲突","link":"#如何解决hash冲突","children":[]}]}],"relativePath":"program/specialColumn/算法专栏/数据结构.md","lastUpdated":1685950556000}'),h={name:"program/specialColumn/算法专栏/数据结构.md"},r=a('<h1 id="数据结构" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构" aria-hidden="true">#</a></h1><h2 id="线性表-链表" tabindex="-1">线性表(链表) <a class="header-anchor" href="#线性表-链表" aria-hidden="true">#</a></h2><h3 id="增、删是o-1-查询o-n" tabindex="-1">增、删是O(1)，查询O(n) <a class="header-anchor" href="#增、删是o-1-查询o-n" aria-hidden="true">#</a></h3><h3 id="价值" tabindex="-1">价值 <a class="header-anchor" href="#价值" aria-hidden="true">#</a></h3><ul><li><p>对数据是按照顺序存储的 如果数据【个数不确定】，数据经常增、删</p></li><li><p>【常见问题】</p><ul><li>单链表的反转</li><li>判断链表是否有环</li></ul></li></ul><h3 id="受限制的线性表" tabindex="-1">受限制的线性表 <a class="header-anchor" href="#受限制的线性表" aria-hidden="true">#</a></h3><ul><li><p>栈（特殊线性表）</p><ul><li><p>功能上链表和数组可以替代栈 但是链表和数组的操作多，暴露了更多的操作接口</p></li><li><p>链式栈（链表栈）</p><ul><li><p>栈顶是单链表的头部</p></li><li><p>top指针指向栈顶</p><ul><li><p>压栈</p><ul><li>1.链表新增操作</li><li>2.移动top指针到链表头</li></ul></li><li><p>弹栈</p><ul><li>移动top指针指向栈顶元素的next指针</li></ul></li></ul></li></ul></li><li><p>【常见问题】</p><ul><li><p>只包含括号的字符串是否合法</p><ul><li>左括号压栈，右括号弹栈</li></ul></li><li><p>浏览器前进后退功能</p><ul><li>维护2个栈， 访问新页面，后退栈压栈 后退页面，后退栈出栈，前进栈压栈 前进页面，前进栈出栈，后退栈压栈</li></ul></li></ul></li></ul></li><li><p>队列</p><ul><li><p>先进先出 新增在队尾 删除在队首</p></li><li><p>顺序队列（数组实现）和链式队列（链表实现） 可以确定队列长度时：使用顺序队列，反之则链式队列</p><ul><li><p>数组实现 需要2个指针，队头指针(front)和队尾(rear)指针 初始时二者指向头节点</p><ul><li><p>不断的进行增加和删除操作时，对头指针和队尾指针不断的向后移动</p><ul><li><p>因为没有实际删除，实际删除会导致数组移动，O(n)时间复杂度</p></li><li><p>所以数组可能会越界（假溢出）</p></li><li><p>解决办法是使用【循环队列】</p><ul><li><p>新增元素时</p><ul><li>判断数组是否已满 如果不满，则将新元素赋值给队尾，rear指针向后移动一个位置</li><li>如果已满，rear指针重新指向头部</li></ul></li><li><p>删除操作时</p><ul><li>判断队列是否为空</li><li>将队头元素赋值给返回值，front指针向后移一个位置</li><li>如果已经到队尾，就把front指针重新指向头部</li></ul></li><li><p>rear指针和front指针重合 可能是空，也可能是满</p><ul><li>设置flag区分是空还是满</li></ul></li></ul></li></ul></li></ul></li><li><p>链表实现 需要2个指针，队头指针(front)和队尾(rear)指针 初始时二者指向头节点 头节点不存储数据，只是用来标识</p><ul><li><p>新增：将新节点赋值给队尾节点的next 也就是rear.next 将rear指向插入的这个节点</p></li><li><p>删除：删除头节点的后继节点 找到头节点的后继 让头节点指向要删除节点的后继</p><ul><li>如果除头节点只剩1个节点，删除后需要将rear指向头节点</li></ul></li><li><p>为什么需要头节点</p><ul><li>防止删掉最后一个元素后 front和rear指针变成野指针，队列没有意义</li></ul></li></ul></li></ul></li><li><p>【常见问题】</p><ul><li>约瑟夫环</li></ul></li></ul></li></ul><h2 id="数组" tabindex="-1">数组 <a class="header-anchor" href="#数组" aria-hidden="true">#</a></h2><h3 id="按顺序存储数据-存储数据的内存是连续的" tabindex="-1">按顺序存储数据，存储数据的内存是连续的 <a class="header-anchor" href="#按顺序存储数据-存储数据的内存是连续的" aria-hidden="true">#</a></h3><p>增删困难，查找容易</p><h3 id="查找o-1-删除o-n-增加-最后插入o-1-其他挪动数组o-n" tabindex="-1">查找O(1),删除O(n)，增加(最后插入O(1),其他挪动数组O(n)) <a class="header-anchor" href="#查找o-1-删除o-n-增加-最后插入o-1-其他挪动数组o-n" aria-hidden="true">#</a></h3><h2 id="字符串" tabindex="-1">字符串 <a class="header-anchor" href="#字符串" aria-hidden="true">#</a></h2><h3 id="有顺序存储-定长数组-和链式存储-一个节点存多个字符-两种" tabindex="-1">有顺序存储(定长数组)和链式存储(一个节点存多个字符)两种 <a class="header-anchor" href="#有顺序存储-定长数组-和链式存储-一个节点存多个字符-两种" aria-hidden="true">#</a></h3><p>链式不如顺序方便和灵活</p><h3 id="字符串的插入-涉及挪移-时间复杂度o-n" tabindex="-1">字符串的插入，涉及挪移，时间复杂度O(n) <a class="header-anchor" href="#字符串的插入-涉及挪移-时间复杂度o-n" aria-hidden="true">#</a></h3><p>字符串的删除，涉及挪移，时间复杂度O(n)</p><h3 id="【常见问题】" tabindex="-1">【常见问题】 <a class="header-anchor" href="#【常见问题】" aria-hidden="true">#</a></h3><ul><li>判断一个子串是否存在（子串查找/字符串匹配）</li><li>求2个字符串的最大公共子串</li></ul><h2 id="树" tabindex="-1">树 <a class="header-anchor" href="#树" aria-hidden="true">#</a></h2><h3 id="链表存储" tabindex="-1">链表存储 <a class="header-anchor" href="#链表存储" aria-hidden="true">#</a></h3><p>数组存储</p><h3 id="二叉树的类型和遍历" tabindex="-1"><a href="https://zack-xy.github.io/knownNet/program/specialColumn/%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F/%E7%AE%97%E6%B3%95%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html" target="_blank" rel="noreferrer">二叉树的类型和遍历</a> <a class="header-anchor" href="#二叉树的类型和遍历" aria-hidden="true">#</a></h3><h3 id="【常见问题】-1" tabindex="-1">【常见问题】 <a class="header-anchor" href="#【常见问题】-1" aria-hidden="true">#</a></h3><ul><li><p>输入一个字符串，判断在字符串集合中是否出现过</p><ul><li>Trie树/字典树</li></ul></li></ul><h2 id="hash表-散列表" tabindex="-1">Hash表（散列表） <a class="header-anchor" href="#hash表-散列表" aria-hidden="true">#</a></h2><h3 id="设计hash函数" tabindex="-1">设计Hash函数 <a class="header-anchor" href="#设计hash函数" aria-hidden="true">#</a></h3><ul><li>直接定制法 H(key) = a * key + b(a,b是设定好的参数)</li><li>数字分析法 集合中都是数字组成的，从中取分布均匀的若干位作为hash</li><li>平方取中法 数字每一位都有某些数字出现，先平方，再取中间几位</li><li>折叠法 如果位数很长，分割为几个等长部分，再相加和</li><li>除留余数法 预先设置一个P，取余</li></ul><h3 id="如何解决hash冲突" tabindex="-1">如何解决hash冲突 <a class="header-anchor" href="#如何解决hash冲突" aria-hidden="true">#</a></h3><ul><li>开放定址法 如果一个hash冲突了，则顺着这个hash向下探测，碰到空单元，就插入进去</li><li>链地址法</li></ul>',29),n=[r];function t(d,s,u,o,p,c){return e(),i("div",null,n)}const g=l(h,[["render",t]]);export{_ as __pageData,g as default};
