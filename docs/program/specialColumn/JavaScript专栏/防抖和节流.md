---
title: 防抖和节流
author: Zack Zheng
date: 2022/02/16 09:51
categories:
 - JavaScript专栏
tags:
 - JavaScript
---

### 为什么要做防抖

有些操作是高频触发的，但其实只需要一次操作就行了
我不管你抖多少次，我只要结果（抖的最后一次）
比如：输入框输入联想（不必每次输入就联想）、拖拽页面大小

#### 防抖的实现：

#### 事件触发->开启定时器->如果再次触发事件，清除定时器重新定时->定时到，触发操作

没有防抖之前：    
我输入：zackzheng，会触发9遍，实际我只要最后一遍

```javascript

// <input type="text" id="inputid" />

var inputDom = document.getElementById('inputid')
inputDom.oninput = function(event) {
    console.log(event.target.value)
}

```

#### 防抖代码实现

```javascript

function debounce(fn, delay) {
    let timer = null
    return function() {
        clearTimeout(timer)
        timer = setTimeout(() => {
            fn.apply(this, arguments)
        }, delay)
    }
}

```

### 为什么要节流

只有防抖，如果我一直操作，则事件就会永远不触发
如果我希望上一次完成之后再触发下一次、每隔一段时间触发，那就是节流

#### 节流的实现：

#### 事件触发->操作执行->阀门关闭->后续事件无效->一定时间或事件结束->阀门开启

#### 节流代码的实现：

```javascript

function throttle(fn, delay) {
    let valid = true
    return function() {
        if(valid) {
            setTimeout(() => {
                fn.apply(this, arguments)
                valid = true
            }, delay)
            valid = false
        }
    }
}


```

----

##### 扩展知识arguments
上述代码中，箭头函数里的arguments是父级作用域的arguments对象，箭头函数不仅没有自己的arguments对象，也没有caller属性，因为箭头函数没有自己的执行上下文，它们只继承了外部函数的执行上下文。
严格模式下，可以使用arguments，和非严格模式相比，有以下几点限制
1. arguments不再是一个类数组对象，无法直接通过索引访问实参，因此arguments[0]是无效的
2. 不能直接修改arguments的值，修改了也对实际参数无影响
3. 禁用arguments.callee属性，不能用arguments.callee递归调用函数自身



